import random

# Define the objective function
def objective_function(position):
    x, y = position
    return x**2 + y**2

# Initialize a particle
class Particle:
    def __init__(self, bounds):
        self.position = [random.uniform(low, high) for low, high in bounds]
        self.velocity = [random.uniform(-1, 1) for _ in bounds]
        self.best_position = self.position[:]
        self.best_value = objective_function(self.position)

    def update_velocity(self, global_best_position, inertia_weight, cognitive_constant, social_constant):
        new_velocity = []
        for i in range(len(self.position)):
            r1 = random.random()
            r2 = random.random()
            cognitive_velocity = cognitive_constant * r1 * (self.best_position[i] - self.position[i])
            social_velocity = social_constant * r2 * (global_best_position[i] - self.position[i])
            new_velocity.append(inertia_weight * self.velocity[i] + cognitive_velocity + social_velocity)
        self.velocity = new_velocity

    def update_position(self, bounds):
        self.position = [
            max(min(self.position[i] + self.velocity[i], bounds[i][1]), bounds[i][0])
            for i in range(len(self.position))
        ]

# Particle Swarm Optimization
def particle_swarm_optimization(
    objective_function,
    bounds,
    num_particles=30,
    max_iterations=100,
    inertia_weight=0.5,
    cognitive_constant=2,
    social_constant=2
):
    # Initialize particles
    swarm = [Particle(bounds) for _ in range(num_particles)]
    global_best_position = swarm[0].position[:]
    global_best_value = objective_function(global_best_position)

    for particle in swarm:
        if particle.best_value < global_best_value:
            global_best_position = particle.best_position[:]
            global_best_value = particle.best_value

    for iteration in range(max_iterations):
        for particle in swarm:
            # Update particle's velocity and position
            particle.update_velocity(global_best_position, inertia_weight, cognitive_constant, social_constant)
            particle.update_position(bounds)
            
            # Evaluate the new position
            value = objective_function(particle.position)
            if value < particle.best_value:
                particle.best_position = particle.position[:]
                particle.best_value = value

                # Update global best if necessary
                if value < global_best_value:
                    global_best_position = particle.best_position[:]
                    global_best_value = value
        
        print(f"Iteration {iteration + 1}: Best value = {global_best_value}, Best position = {global_best_position}")

    return global_best_position, global_best_value

# Run the PSO algorithm
if __name__ == "__main__":
    # Define bounds for the variables (e.g., x and y are in [-10, 10])
    bounds = [(-10, 10), (-10, 10)]
    
    # Execute the PSO
    best_position, best_value = particle_swarm_optimization(objective_function, bounds)
    print(f"Optimal solution: Position = {best_position}, Value = {best_value}")
