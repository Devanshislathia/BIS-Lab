import numpy as np

# Objective function
def objective_function(x):
    return sum(xi**2 for xi in x)

# Levy flight step
def levy_flight(Lambda):
    u = np.random.normal(0, 1)
    v = np.random.normal(0, 1)
    step = u / abs(v)**(1 / Lambda)
    return step

# Generate new solution
def generate_new_solution(solution, best_solution, bounds, step_size=0.01):
    new_solution = np.copy(solution)
    for i in range(len(solution)):
        step = levy_flight(1.5) * (solution[i] - best_solution[i])
        new_solution[i] += step * step_size
        new_solution[i] = np.clip(new_solution[i], bounds[i][0], bounds[i][1])  # Keep within bounds
    return new_solution

# Cuckoo Search Algorithm
def cuckoo_search(
    objective_function,
    num_nests=25,
    max_iterations=100,
    discovery_rate=0.25,
    bounds=[(-5, 5), (-5, 5)]
):
    num_variables = len(bounds)
    
    # Initialize nests randomly
    nests = np.array([
        [np.random.uniform(low, high) for low, high in bounds]
        for _ in range(num_nests)
    ])
    fitness = np.array([objective_function(nest) for nest in nests])
    
    # Find the current best solution
    best_nest_index = np.argmin(fitness)
    best_solution = nests[best_nest_index]
    best_fitness = fitness[best_nest_index]
    
    for iteration in range(max_iterations):
        new_nests = np.array([
            generate_new_solution(nest, best_solution, bounds)
            for nest in nests
        ])
        
        # Evaluate fitness of new solutions
        new_fitness = np.array([objective_function(nest) for nest in new_nests])
        
        # Update nests if new solutions are better
        for i in range(num_nests):
            if new_fitness[i] < fitness[i]:
                nests[i] = new_nests[i]
                fitness[i] = new_fitness[i]
        
        # Abandon some nests (discovery by other species)
        num_discovered = int(discovery_rate * num_nests)
        discovered_indices = np.random.choice(range(num_nests), num_discovered, replace=False)
        for i in discovered_indices:
            nests[i] = np.array([np.random.uniform(low, high) for low, high in bounds])
            fitness[i] = objective_function(nests[i])
        
        # Update the best solution
        best_nest_index = np.argmin(fitness)
        if fitness[best_nest_index] < best_fitness:
            best_fitness = fitness[best_nest_index]
            best_solution = nests[best_nest_index]
        
        print(f"Iteration {iteration + 1}: Best fitness = {best_fitness}")
    
    return best_solution, best_fitness

# Example usage
if __name__ == "__main__":
    # Define bounds for the problem (e.g., 2 variables within [-5, 5])
    bounds = [(-5, 5), (-5, 5)]
    
    # Run Cuckoo Search
    best_solution, best_fitness = cuckoo_search(objective_function, bounds=bounds)
    print(f"Optimal solution: {best_solution}, Best fitness: {best_fitness}")
